CS564 Assignment 1 - Report
Student Name: Liang Zheng Gooi    
UW Campus ID: 9066169518    
email: lgooi@wisc.edu
Time: February 1, 10.00am

1. Explain your choice of the data structure that you implemented. Did you consider any other data structures besides the one that you implemented? How did you arrive at your final choice of the data structure?
    -I am using map structure as the base structure, with char* as key and vector<int> as value. Since map is using the implementation of red-black tree, the complexity for inserting, deleting and searching would be O(log(size)) for worst and average case.
    -Initially my idea would be constructing a heap which uses AVL tree and struct nodes that contains string and array of integer. With the AVL tree and customised struct, I could yield O(log(N)) for the operations and O(1) for accessing into the integer array. However, both heap and integer array are using array, which needed to be reallocated each time when the size is expanding. This requires copying each elements from the old array to a new larger array and deallocate the old ones. This would cause the insertion to be O(N) and extra lines of code for the implementation.
    -In the end I choose map structure as my data structure because the map is being provided in <map> library and there are useful functions to get things done rather than building from scratch. Map also performs as well as heap where the complexity is O(log(N)) for the operations. For the value for each key, I am using vector as provided in the library. Vector simulates the implementation of dynamically allocated array, and provides useful functions to manage the structure. Although there will be O(N) in inserting and deleting, the searching will be in constant time. Therefore the overall performance of the structure will be O(log(N)) for searching, and O(Nlog(N)) for adding and deleting. With the map and vector as the data structure, the program become easy to manage and perform as well as combination of heap and array.


2. What is the best, average, and worst case complexity of your implementation of the locate command in terms of the number of words in the file that you are querying? (you need to provide all three - best, average, and worst-case analysis). For the complexity, I am only interested in the big-Oh analysis.
I am implementing map structure which uses the structure of red-black tree. Since red-black tree is a balanced binary tree, the average and the worst case will be O(log(N)). The mechanism behind complexity of O(log(N)) is that each pair in the map will have at maximum 2 children, where the parent is valued between the two children. This structure provide an easy way to get to the target by comparing the requested word with the parent node, and proceed to the correct child node after comparing. The best case will be O(1), where the first node of the map is the requested word.  Besides that, I am implementing vector as the value for the map, which produce the complexity of O(1) for abstracting the location of requested word on worst, average and best case. In the end, the whole data structure provide me O(1) for best case, and O(log(N)) for average and worst case.

3. What is the average case space complexity of your data structure in terms of the number of words in the input file? In other words, using the big-Oh notation what is the expected average size of your data structure in terms of the number of words.
Let the number of words to be N. The vector array will have average space complexity of 2 bytes per word, thus there will be O(N) for vectorâ€™s space complexity. For the space complexity of map, it will be less than N because in average case there will be duplication of words and punctuation in a text file. Therefore, we assume that the average space complexity for map is O(N). This gives us the space complexity of O(N^2). However, this is not the average case, since there will be less than N word variety. In conclusion, the average space complexity lies between O(N), where there are words duplicated and consist of punctuation, and O(N^2), where there are no words duplication and no punctuation, which means that O(N) < average < O(N^2).
